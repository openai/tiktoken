use std::collections::HashMap as StdHashMap;
use std::sync::Arc;
use rustc_hash::FxHashMap as HashMap;

use crate::{CoreBPE as CoreBPEInternal, Rank};

// UniFfiTag is auto-generated by the scaffolding macro

#[derive(Debug, thiserror::Error)]
pub enum TiktokenError {
    #[error("Regex error: {message}")]
    RegexError { message: String },
    #[error("Decode error: {message}")]
    DecodeError { message: String },
}

/// Minimal wrapper around CoreBPE for UniFFI
/// All base64 encoding/decoding for non-UTF8 tokens is handled in Swift
#[derive(Clone)]
pub struct CoreBpe {
    inner: CoreBPEInternal,
}

impl CoreBpe {
    pub fn new(
        encoder: StdHashMap<Vec<u8>, u32>,
        special_tokens_encoder: StdHashMap<String, u32>,
        pattern: String,
    ) -> Result<Self, TiktokenError> {
        // Convert to the expected HashMap type
        let encoder: HashMap<Vec<u8>, Rank> = encoder.into_iter().collect();
        let special_tokens_encoder: HashMap<String, Rank> = special_tokens_encoder.into_iter().collect();
        
        let inner = CoreBPEInternal::new(encoder, special_tokens_encoder, &pattern)
            .map_err(|e| TiktokenError::RegexError { message: e.to_string() })?;
            
        Ok(Self { inner })
    }
    
    pub fn encode(&self, text: String, allowed_special: Vec<String>) -> Vec<u32> {
        use std::collections::HashSet;
        let allowed_special: HashSet<&str> = allowed_special.iter().map(|s| s.as_str()).collect();
        self.inner.encode(&text, &allowed_special).unwrap().0
    }
    
    pub fn encode_ordinary(&self, text: String) -> Vec<u32> {
        self.inner.encode_ordinary(&text)
    }
    
    pub fn encode_with_special_tokens(&self, text: String) -> Vec<u32> {
        self.inner.encode_with_special_tokens(&text)
    }
    
    pub fn decode_bytes(&self, tokens: Vec<u32>) -> Result<Vec<u8>, TiktokenError> {
        self.inner.decode_bytes(&tokens)
            .map_err(|e| TiktokenError::DecodeError { message: format!("Token {} not found", e.token) })
    }
}

/// Create a new CoreBpe instance
pub fn new_core_bpe(
    encoder: StdHashMap<Vec<u8>, u32>,
    special_tokens_encoder: StdHashMap<String, u32>,
    pattern: String,
) -> Result<Arc<CoreBpe>, TiktokenError> {
    Ok(Arc::new(CoreBpe::new(encoder, special_tokens_encoder, pattern)?))
}

uniffi::include_scaffolding!("tiktoken");